<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <title>Logshor Monitor · Pair</title>
    <style>
        :root {
            color-scheme: dark;
            font-family: "Segoe UI", system-ui, sans-serif;
        }

        body {
            margin: 0;
            background: #05080d;
            color: #f0f2f6;
        }

        .page-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            background: #0a0f15;
        }

        .page-header h1 {
            margin: 0.25rem 0 0;
            font-size: 1.6rem;
        }

        .back-link {
            color: #9fb7ff;
            text-decoration: none;
            font-size: 0.95rem;
        }

        main {
            padding: 1.25rem 1.5rem 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
        }

        .metric-card {
            padding: 0.7rem 1rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.01);
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .metric-card span {
            font-size: 0.78rem;
            color: #9fb7ff;
        }

        .metric-card strong {
            font-size: 1.3rem;
        }

        .metric-note {
            font-size: 0.76rem;
            color: #b0c7ff;
        }

        .chart-wrapper {
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.02);
            box-shadow: 0 25px 40px rgba(0, 0, 0, 0.5);
        }

        canvas {
            width: 100%;
            height: 360px;
            display: block;
        }

        .chart-meta {
            margin-top: 0.7rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
            color: #a9b9ff;
        }

        .chart-note,
        #error-msg {
            color: #c9d5ff;
            font-size: 0.85rem;
        }

        #error-msg {
            color: #ffb2ae;
        }
    </style>
</head>
<body>
    <header class="page-header">
        <a href="/monitor/" class="back-link">← Voltar ao monitor</a>
        <h1>{{ pair }}</h1>
        <p class="chart-note">Histórico de até 600 ticks · atualiza a cada 1s · thresholds visíveis abaixo.</p>
    </header>
    <main>
        <section class="metrics-grid">
            <article class="metric-card">
                <span>Z atual</span>
                <strong id="metric-z">–</strong>
                <span class="metric-note" id="metric-z-note">enter thresholds carregando</span>
            </article>
            <article class="metric-card">
                <span>Spread</span>
                <strong id="metric-spread">–</strong>
            </article>
            <article class="metric-card">
                <span>pa</span>
                <strong id="metric-pa">–</strong>
            </article>
            <article class="metric-card">
                <span>pb</span>
                <strong id="metric-pb">–</strong>
            </article>
            <article class="metric-card">
                <span>Status</span>
                <strong id="metric-status">–</strong>
            </article>
            <article class="metric-card">
                <span>Signal</span>
                <strong id="metric-signal">–</strong>
            </article>
            <article class="metric-card">
                <span>Side</span>
                <strong id="metric-side">–</strong>
            </article>
            <article class="metric-card">
                <span>Última atualização</span>
                <strong id="metric-updated">–</strong>
            </article>
            <article class="metric-card">
                <span>Maior |z| desde a abertura</span>
                <strong id="metric-z-max">–</strong>
            </article>
            <article class="metric-card">
                <span>Tempo na posição</span>
                <strong id="metric-time-in-trade">–</strong>
            </article>
            <article class="metric-card">
                <span>Abertura</span>
                <strong id="metric-opened-at">–</strong>
            </article>
        </section>
        <section class="chart-wrapper">
            <canvas id="z-chart" width="1100" height="360"></canvas>
            <div class="chart-meta">
                <span id="chart-range">thresholds: enter ±? / exit ±?</span>
                <span id="chart-status">carregando histórico...</span>
            </div>
            <p class="chart-note" id="chart-note">A linha azul representa o z-score, os riscos são marcados.</p>
            <p id="error-msg"></p>
        </section>
    </main>
    <script>
        (() => {
            const pairName = "{{ pair|escapejs }}";
            const encodedPair = encodeURIComponent(pairName);
            const historyUrl = `/api/monitor/history/?pair=${encodedPair}&limit=600`;
            const canvas = document.getElementById("z-chart");
            const ctx = canvas.getContext("2d");
            const metricEls = {
                z: document.getElementById("metric-z"),
                spread: document.getElementById("metric-spread"),
                pa: document.getElementById("metric-pa"),
                pb: document.getElementById("metric-pb"),
                status: document.getElementById("metric-status"),
                signal: document.getElementById("metric-signal"),
                side: document.getElementById("metric-side"),
                updated: document.getElementById("metric-updated"),
                zMax: document.getElementById("metric-z-max"),
                timeInTrade: document.getElementById("metric-time-in-trade"),
                openedAt: document.getElementById("metric-opened-at"),
                zNote: document.getElementById("metric-z-note"),
            };
            const chartRange = document.getElementById("chart-range");
            const chartStatus = document.getElementById("chart-status");
            const errorEl = document.getElementById("error-msg");
            let lastChartData = { points: [], params: { enter_z: 2.3, exit_band: 0.3 } };
            const now = () => new Date();

            const formatNumber = (value, digits = 2) => {
                if (value == null) {
                    return "–";
                }
                return Number(value).toFixed(digits);
            };

            const parseNumber = (value) => {
                if (value == null || value === "") {
                    return null;
                }
                if (typeof value === "number") {
                    return Number.isFinite(value) ? value : null;
                }
                const parsed = Number(value);
                return Number.isFinite(parsed) ? parsed : null;
            };

            const formatDuration = (ms) => {
                const totalSeconds = Math.floor(Math.max(ms, 0) / 1000);
                const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
                const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
                const seconds = String(totalSeconds % 60).padStart(2, "0");
                return `${hours}:${minutes}:${seconds}`;
            };

            const computeTradeInfo = (points) => {
                let openedAt = null;
                let openedIndex = null;
                for (let i = points.length - 1; i >= 0; i--) {
                    const row = points[i];
                    if (row.signal === "IN_POSITION") {
                        openedAt = row.ts;
                        openedIndex = i;
                    } else if (openedAt !== null) {
                        break;
                    }
                }
                if (!openedAt) {
                    return { openedAt: null, timeInTrade: "–", zMaxAbs: null };
                }
                const opened = new Date(openedAt);
                const elapsed = Math.max(0, Date.now() - opened.getTime());
                const block = points.slice(openedIndex ?? 0);
                let maxAbs = 0;
                block.forEach(pt => {
                    const z = parseNumber(pt.z);
                    if (z != null) {
                        maxAbs = Math.max(maxAbs, Math.abs(z));
                    }
                });
                return {
                    openedAt,
                    timeInTrade: formatDuration(elapsed),
                    zMaxAbs: maxAbs,
                };
            };

            const setCanvasSize = () => {
                const maxWidth = Math.max(600, document.documentElement.clientWidth - 60);
                canvas.width = Math.min(1100, maxWidth);
                canvas.height = 360;
            };

            const drawChart = (points, params) => {
                if (!ctx) {
                    return;
                }
                const width = canvas.width;
                const height = canvas.height;
                const padding = { left: 60, right: 30, top: 30, bottom: 30 };
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = "rgba(255, 255, 255, 0.02)";
                ctx.fillRect(0, 0, width, height);

                const numericPoints = [];
                points.forEach((pt, idx) => {
                    const z = parseNumber(pt.z);
                    if (z != null) {
                        numericPoints.push({ idx, z });
                    }
                });

                const enterZ = parseNumber(params.enter_z) ?? 2.3;
                const exitBand = parseNumber(params.exit_band) ?? 0.3;
                const thresholds = [
                    { value: enterZ, label: "enter", color: "#f39c12" },
                    { value: -enterZ, label: "enter", color: "#f39c12" },
                    { value: exitBand, label: "exit", color: "#8ba0ff" },
                    { value: -exitBand, label: "exit", color: "#8ba0ff" },
                ];

                const values = numericPoints.map(p => p.z).concat(thresholds.map(t => t.value));
                let minZ = Math.min(...values);
                let maxZ = Math.max(...values);
                if (!Number.isFinite(minZ)) minZ = -2;
                if (!Number.isFinite(maxZ)) maxZ = 2;
                if (Math.abs(maxZ - minZ) < 0.5) {
                    const mid = (maxZ + minZ) / 2;
                    minZ = mid - 0.5;
                    maxZ = mid + 0.5;
                }

                const drawWidth = width - padding.left - padding.right;
                const drawHeight = height - padding.top - padding.bottom;
                const valueToY = (value) => padding.top + ((maxZ - value) / (maxZ - minZ)) * drawHeight;
                const xForIndex = (i) => {
                    if (points.length <= 1) {
                        return padding.left + drawWidth / 2;
                    }
                    return padding.left + (i / (points.length - 1)) * drawWidth;
                };

                thresholds.forEach(({ value, label, color }) => {
                    if (!Number.isFinite(value)) {
                        return;
                    }
                    const y = valueToY(value);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = color;
                    ctx.font = "11px Segoe UI";
                    ctx.fillText(`${label} ${value.toFixed(2)}`, width - padding.right + 6, y + 4);
                });

                ctx.strokeStyle = "rgba(255, 255, 255, 0.35)";
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                const zeroY = valueToY(0);
                ctx.moveTo(padding.left, zeroY);
                ctx.lineTo(width - padding.right, zeroY);
                ctx.stroke();
                ctx.setLineDash([]);

                if (numericPoints.length > 0) {
                    ctx.strokeStyle = "#4ec0ff";
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    numericPoints.forEach((pt, index) => {
                        const x = xForIndex(pt.idx);
                        const y = valueToY(pt.z);
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();

                    const lastPoint = numericPoints[numericPoints.length - 1];
                    const lastX = xForIndex(lastPoint.idx);
                    const lastY = valueToY(lastPoint.z);
                    ctx.fillStyle = Math.abs(lastPoint.z) >= enterZ ? "#ff6b6b" : "#4ec0ff";
                    ctx.beginPath();
                    ctx.arc(lastX, lastY, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.fillStyle = "#9fb7ff";
                ctx.font = "12px Segoe UI";
                const arrow = "\u2192";
                ctx.fillText(`range: ${minZ.toFixed(2)} ${arrow} ${maxZ.toFixed(2)}`, padding.left, padding.top - 8);

                lastChartData = { points, params };
            };

            const updateMetrics = (points, payload) => {
                const lastPoint = points.length ? points[points.length - 1] : null;
                metricEls.z.textContent = lastPoint && lastPoint.z != null ? formatNumber(lastPoint.z) : "–";
                metricEls.spread.textContent = lastPoint && lastPoint.spread != null ? formatNumber(lastPoint.spread, 6) : "–";
                metricEls.pa.textContent = lastPoint && lastPoint.pa != null ? formatNumber(lastPoint.pa, 5) : "–";
                metricEls.pb.textContent = lastPoint && lastPoint.pb != null ? formatNumber(lastPoint.pb, 5) : "–";
                metricEls.status.textContent = lastPoint && lastPoint.status ? lastPoint.status : "–";
                metricEls.signal.textContent = lastPoint && lastPoint.signal ? lastPoint.signal : "–";
                metricEls.side.textContent = lastPoint && lastPoint.side ? lastPoint.side : "–";
                const updatedTs = payload.ts ? new Date(payload.ts).toLocaleTimeString() : now().toLocaleTimeString();
                metricEls.updated.textContent = updatedTs;
                const tradeInfo = computeTradeInfo(points);
                metricEls.zMax.textContent = tradeInfo.zMaxAbs ? tradeInfo.zMaxAbs.toFixed(2) : "–";
                metricEls.timeInTrade.textContent = tradeInfo.timeInTrade;
                metricEls.openedAt.textContent = tradeInfo.openedAt ? new Date(tradeInfo.openedAt).toLocaleTimeString() : "–";
                const params = payload.params || lastChartData.params;
                const enterZ = parseNumber(params.enter_z);
                const exitBand = parseNumber(params.exit_band);
                const enterLabel = enterZ != null ? enterZ.toFixed(2) : "?";
                const exitLabel = exitBand != null ? exitBand.toFixed(2) : "?";
                const pm = "\u00B1";
                metricEls.zNote.textContent = enterZ != null ? `enter ${pm}${enterLabel}` : "enter thresholds carregando";
                chartRange.textContent = `thresholds: enter ${pm}${enterLabel}, exit ${pm}${exitLabel}`;
                chartStatus.textContent = lastPoint && lastPoint.wake
                    ? "WAKE detectado"
                    : lastPoint
                        ? `ultimo signal: ${lastPoint.signal || "–"}`
                        : "sem dados";
            };

            const handleApiError = async (response) => {
                let detail = response.statusText || "falha ao carregar histórico";
                try {
                    const body = await response.json();
                    if (body && typeof body.error === "string") {
                        detail = body.error;
                    }
                } catch {
                    // ignore parsing failures; keep fallback
                }
                const msg = response.status === 404 ? "pair not found" : detail;
                errorEl.textContent = msg;
                chartStatus.textContent = msg;
            };

            const refresh = async () => {
                try {
                    const response = await fetch(historyUrl, { cache: "no-store" });
                    if (!response.ok) {
                        await handleApiError(response);
                        return;
                    }
                    const payload = await response.json();
                    errorEl.textContent = "";
                    const points = Array.isArray(payload.points) ? payload.points : [];
                    const params = payload.params || lastChartData.params;
                    updateMetrics(points, { ts: payload.ts, params });
                    drawChart(points, params);
                } catch (error) {
                    errorEl.textContent = error.message;
                    chartStatus.textContent = "falha ao carregar histórico";
                } finally {
                    setTimeout(refresh, 1000);
                }
            };

            setCanvasSize();
            window.addEventListener("resize", () => {
                setCanvasSize();
                if (lastChartData.points.length) {
                    drawChart(lastChartData.points, lastChartData.params);
                }
            });

            refresh();
        })();
    </script>
</body>
</html>
